/*
 * Copyright (c) 2010 People Power Company
 * All rights reserved.
 *
 * This open source code was developed with funding from People Power Company
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the
 *   distribution.
 * - Neither the name of the People Power Corporation nor the names of
 *   its contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * PEOPLE POWER CO. OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE
 */

/**
 * This module is responsible for activating the proxy with the server,
 * which will link the physical instance of this proxy to a group or username.
 * There are multiple ways to do this, and this activation functionality
 * here is only one of those multiple ways.
 *
 * @author David Moss
 */


#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdbool.h>
#include <rpc/types.h>
#include <stdio.h>

#include <libxml/parser.h>

#include "libhttpcomm.h"
#include "libconfigio.h"
#include "eui64.h"
#include "proxyserver.h"
#include "proxyactivation.h"
#include "proxycli.h"
#include "ioterror.h"
#include "iotdebug.h"
#include "proxycli.h"
#include "proxy.h"


/***************** Private Prototypes ****************/
static void _proxyactivation_xml_startElementHandler(void *ctx, const xmlChar *name, const xmlChar **atts);

static void _proxyactivation_xml_charactersHandler(void *ctx, const xmlChar *ch, int len);


/***************** Public Functions ***************/
/**
 * Activate this proxy
 *
 * To activate, we need 4 things:
 *   1. The activation key, generated by the server which maps to the user's login
 *   2. The MAC address of this proxy
 *   3. The device type of this proxy, usually type 3
 *   4. The activation URL to send the request to
 *
 * We pass in the activation key from the command line
 * We obtain the MAC address through the EUI64 module.
 * We obtain the device type and activation URL from the configuration file
 *
 * @param activationKey the key to activate with
 * @return SUCCESS if the proxy was activated, FAIL if it wasn't
 */
error_t proxyactivation_activate(const char *activationKey) {
  char eui64[EUI64_STRING_SIZE];
  char url[PATH_MAX];
  char deviceType[8];
  char rxBuffer[PROXY_MAX_MSG_LEN];
  char oBuffer[PROXY_MAX_MSG_LEN];
  http_param_t params;
  activation_info_t activationInfo;

  xmlSAXHandler saxHandler = {
      NULL, // internalSubsetHandler,
      NULL, // isStandaloneHandler,
      NULL, // hasInternalSubsetHandler,
      NULL, // hasExternalSubsetHandler,
      NULL, // resolveEntityHandler,
      NULL, // getEntityHandler,
      NULL, // entityDeclHandler,
      NULL, // notationDeclHandler,
      NULL, // attributeDeclHandler,
      NULL, // elementDeclHandler,
      NULL, // unparsedEntityDeclHandler,
      NULL, // setDocumentLocatorHandler,
      NULL, // startDocument
      NULL, // endDocument
      _proxyactivation_xml_startElementHandler, // startElement
      NULL, // endElement
      NULL, // reference,
      _proxyactivation_xml_charactersHandler, //characters
      NULL, // ignorableWhitespace
      NULL, // processingInstructionHandler,
      NULL, // comment
      NULL, // warning
      NULL, // error
      NULL, // fatal
  };

  bzero(deviceType, sizeof(deviceType));

  // Get the EUI64 unique device id for the proxy
  if(eui64_toString(eui64, sizeof(eui64)) != SUCCESS) {
    return FAIL;
  }

  // Read the activation URL from the configuration file
  if(libconfigio_read(proxycli_getConfigFilename(), CONFIGIO_ACTIVATION_URL_TOKEN_NAME, url, sizeof(url)) == -1) {
    printf("Couldn't read %s in file %s, writing default value\n", CONFIGIO_ACTIVATION_URL_TOKEN_NAME, proxycli_getConfigFilename());
    libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_ACTIVATION_URL_TOKEN_NAME, DEFAULT_ACTIVATION_URL);
    strncpy(url, DEFAULT_ACTIVATION_URL, sizeof(url));
  }

  // Read the device type from the configuration file
  if(libconfigio_read(proxycli_getConfigFilename(), CONFIGIO_PROXY_DEVICE_TYPE_TOKEN_NAME, deviceType, sizeof(deviceType)) == -1) {
    printf("Couldn't read %s in file %s, writing default value\n", CONFIGIO_PROXY_DEVICE_TYPE_TOKEN_NAME, proxycli_getConfigFilename());
    libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_PROXY_DEVICE_TYPE_TOKEN_NAME, DEFAULT_PROXY_DEVICETYPE);
    strncpy(deviceType, DEFAULT_PROXY_DEVICETYPE, sizeof(deviceType));
  }

  snprintf(oBuffer, sizeof(oBuffer), "<request>\n"
    "<hubActivation>\n"
    "<activationKey>%s</activationKey>\n"
    "<hubId>%s</hubId>\n"
    "<deviceType>%s</deviceType>\n"
    "</hubActivation>\n"
    "</request>\n", activationKey, eui64, deviceType);

  params.verbose = TRUE;
  params.timeouts.connectTimeout = HTTPCOMM_DEFAULT_CONNECT_TIMEOUT_SEC;
  params.timeouts.transferTimeout = HTTPCOMM_DEFAULT_TRANSFER_TIMEOUT_SEC;

  libhttpcomm_sendMsg(NULL, CURLOPT_POST, url, NULL, NULL, oBuffer, strlen(oBuffer), rxBuffer, sizeof(rxBuffer), params, NULL);

  if(0 != xmlSAXUserParseMemory(&saxHandler, &activationInfo, rxBuffer, strlen(rxBuffer))) {
    return FAIL;
  }



  if(activationInfo.resultCode == 0) {
    libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_PROXY_ACTIVATION_KEY, activationKey);
    return SUCCESS;

  } else {
    return FAIL;
  }
}


/***************** Private Functions ****************/
/**
 * Parse a new XML tag
 */
static void _proxyactivation_xml_startElementHandler(void *ctx, const xmlChar *name, const xmlChar **atts) {
    // Know which tag we're grabbing character data out of
    snprintf(((activation_info_t *) ctx)->xmlTag, ACTIVATION_XML_TAG_SIZE, "%s", (char *) name);
}

/**
 * Parse the characters found as the value of an XML tag
 */
static void _proxyactivation_xml_charactersHandler(void *ctx, const xmlChar *ch, int len) {
  int i;
  char output[ACTIVATION_XML_VALUE_SIZE];
  activation_info_t *activationInfo = (activation_info_t *) ctx;

  if (len > 0 && len < ACTIVATION_XML_VALUE_SIZE) {
    for (i = 0; i < len; i++) {
      //if not equal a LF, CR store the character
      if ((ch[i] != 10) && (ch[i] != 13)) {
        output[i] = ch[i];
      }
    }
    output[i] = '\0';

    if (strcmp(activationInfo->xmlTag, "response") == 0) {
      // Tag is ok, but do nothing

    } else if (strcmp(activationInfo->xmlTag, "hubActivation") == 0) {
      // Tag is ok, but do nothing

    } else if (strcmp(activationInfo->xmlTag, "resultCode") == 0) {
      activationInfo->resultCode = atoi(output);

    } else if (strcmp(activationInfo->xmlTag, "host") == 0) {
      libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_CLOUD_HOST, output);

    } else if (strcmp(activationInfo->xmlTag, "port") == 0) {
      libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_CLOUD_PORT, output);

    } else if (strcmp(activationInfo->xmlTag, "uri") == 0) {
      libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_CLOUD_URI, output);

    } else if (strcmp(activationInfo->xmlTag, "useSSL") == 0) {
      libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_CLOUD_USE_SSL, output);

    } else if (strcmp(activationInfo->xmlTag, "deviceAuthToken") == 0) {
      libconfigio_write(proxycli_getConfigFilename(), CONFIGIO_CLOUD_ACTIVATION_KEY, output);

    } else {
      SYSLOG_DEBUG("Activation does not support XML tag %s", activationInfo->xmlTag);
    }

  } else {
    SYSLOG_ERR("Received an XML value that is too long to parse");
  }
}




